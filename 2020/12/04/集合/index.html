<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Java集合框架Collection接口在Java类库中，集合类的基本接口是Collection接口，这个接口有两个基本方法： 12345public interface Collection&lt;E&gt;&amp;#123;    public add(E ele);    Iterator&lt;E&gt; iterator();    ...&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="http://example.com/2020/12/04/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="XDBLOG">
<meta property="og:description" content="Java集合框架Collection接口在Java类库中，集合类的基本接口是Collection接口，这个接口有两个基本方法： 12345public interface Collection&lt;E&gt;&amp;#123;    public add(E ele);    Iterator&lt;E&gt; iterator();    ...&amp;#125;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-04T03:16:51.000Z">
<meta property="article:modified_time" content="2020-12-10T09:18:30.773Z">
<meta property="article:author" content="陈旭东">
<meta property="article:tag" content="OOP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/12/04/%E9%9B%86%E5%90%88/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>集合 | XDBLOG</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XDBLOG</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">Collection接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">泛型实用方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">具体集合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">数组列表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E9%9B%86"><span class="nav-number">2.3.</span> <span class="nav-text">散列集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91%E9%9B%86"><span class="nav-number">2.4.</span> <span class="nav-text">树集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.5.</span> <span class="nav-text">队列和双端队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">2.6.</span> <span class="nav-text">优先级队列</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">3.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">基本映射操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.2.</span> <span class="nav-text">更新映射条目</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E8%A7%86%E5%9B%BE"><span class="nav-number">3.3.</span> <span class="nav-text">映射视图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%B1%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="nav-number">3.4.</span> <span class="nav-text">弱散列映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-number">3.5.</span> <span class="nav-text">链接散列集与映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-number">3.6.</span> <span class="nav-text">枚举集与映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="nav-number">3.7.</span> <span class="nav-text">标识散列映射</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">视图与包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%8F%E9%9B%86%E5%90%88"><span class="nav-number">4.1.</span> <span class="nav-text">小集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%90%E8%8C%83%E5%9B%B4"><span class="nav-number">4.2.</span> <span class="nav-text">子范围</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="nav-number">4.3.</span> <span class="nav-text">不可修改的视图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E8%A7%86%E5%9B%BE"><span class="nav-number">4.4.</span> <span class="nav-text">同步视图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%9E%8B%E8%A7%86%E5%9B%BE"><span class="nav-number">4.5.</span> <span class="nav-text">检查型视图</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B7%B7%E6%8E%92"><span class="nav-number">5.1.</span> <span class="nav-text">排序与混排</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">5.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.</span> <span class="nav-text">集合与数组的转换</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈旭东"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">陈旭东</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cxd-scu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cxd-scu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1785195344@qq.com" title="E-Mail → 1785195344@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/04/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="陈旭东">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XDBLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-04 11:16:51" itemprop="dateCreated datePublished" datetime="2020-12-04T11:16:51+08:00">2020-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-10 17:18:30" itemprop="dateModified" datetime="2020-12-10T17:18:30+08:00">2020-12-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h5 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h5><h6 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h6><p>在Java类库中，集合类的基本接口是Collection接口，这个接口有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">(E ele)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>add方法用于向集合中添加元素，如果添加元素确实改变了集合就返回true，集合没有变化则返回false。</p>
<p>iterator方法用于返回一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。</p>
<h6 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h6><p>Iterator接口包含四个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反复调用next方法可以逐个访问集合中的每个元素，但如果到了集合的末尾，next方法就会抛出一个NoSuchElementException，因此，需要在调用next前调用hasNext方法，如果迭代器还有可以访问的元素，这个方法就返回true。如果想访问集合中的全部元素，就请求一个迭代器，并在hasNext返回true时反复的调用next方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    String str = iter.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用for each循环，编译器会将for each循环转换为带有迭代器的循环。for each循环可以处理任何实现了Iterable接口的对象，这个接口只包含一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用for each循环。</p>
<p>也可以不写循环，而是调用forEachRemaining方法并提供一个lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something );</span><br></pre></td></tr></table></figure>

<p>可以认为Java的迭代器位于两个元素之间，调用next元素时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>remove方法将会删除上次调用next方法时返回的元素。</p>
<h6 id="泛型实用方法"><a href="#泛型实用方法" class="headerlink" title="泛型实用方法"></a>泛型实用方法</h6><p>Collection接口有许多有用的默认方法：</p>
<ul>
<li><p>Iterator&lt;E&gt; iterator()</p>
<p>返回一个用于访问集合中各个元素的迭代器</p>
</li>
<li><p>int size()</p>
<p>返回当前储存在集合中的元素个数</p>
</li>
<li><p>boolean isEmpty()</p>
<p>如果集合中没有元素，返回true</p>
</li>
<li><p>boolean contains(Object obj) </p>
<p>如果集合中包含了一个与obj相等的对象，返回true</p>
</li>
<li><p>boolean containsAll(Clooection&lt;?&gt; other) </p>
<p>如果这个集合包含other集合中的所有元素，返回true</p>
</li>
<li><p>boolean add(E element) </p>
<p>将一个元素添加到集合中，如果这个调用改变了集合，返回true</p>
</li>
<li><p>boolean addAll(E element) </p>
<p>将一个集合中所有元素添加到这个集合，若这个调用改变了集合，返回true</p>
</li>
<li><p>boolean remove(Object obj) </p>
<p>从集合中删除等于obj的对象，若有匹配的对象被删除，返回true</p>
</li>
<li><p>boolean removeAll(Collection&lt;?&gt; other) </p>
<p>从集合中删除other集合中存在的所有元素，若这个调用改变了集合，返回true</p>
</li>
<li><p>default boolean removeIf(Predicate&lt;? super E&gt; fliter)</p>
<p> 从集合中删除filter返回true的所有元素，若集合改变，返回true</p>
</li>
<li><p>void clear() </p>
<p>从这个集合中删除所有的元素</p>
</li>
<li><p>boolean retainAll(Collection&lt;?&gt; other) </p>
<p>从这个集合中删除所有与other集合中元素不同的元素，若改变了集合，返回true</p>
</li>
<li><p>Object[] toArray() </p>
<p>返回集合中的对象的数组</p>
</li>
<li><p>&lt;T&gt; T[] toArray(T[] arrayToFill) </p>
<p>返回集合中的对象的数组，若arrayToFill足够大，就填充arrayToFill，剩余空间填补null；否则分配一个新数组</p>
</li>
</ul>
<h5 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h5><p>下面展示了Java类库中的集合，并简要描述了每个集合类的用途，表中，以Map结尾的实现了Map接口，剩余的则实现了Collection接口。</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可以动态增长或是缩减的一个索引序列</td>
</tr>
<tr>
<td>LinkedList</td>
<td>可以在任何位置高效插入或删除的一个有序序列</td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>实现为循环数组的一个双端队列</td>
</tr>
<tr>
<td>HashSet</td>
<td>没有重复元素的一个无序集合</td>
</tr>
<tr>
<td>TreeSet</td>
<td>一个有序集</td>
</tr>
<tr>
<td>EnumSet</td>
<td>一个包含枚举类型值的集</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>一个可以记住元素插入次序的集</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>允许高效删除最小元素的一个集合</td>
</tr>
<tr>
<td>HashMap</td>
<td>存储键/值关联的一个数据结构</td>
</tr>
<tr>
<td>TreeMap</td>
<td>键有序地一个映射</td>
</tr>
<tr>
<td>EnumMap</td>
<td>键属于枚举类型的一个映射</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>可以记住键/值项添加次序的一个映射</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>值不会在别处使用时就可以被垃圾回收的一个映射</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>用==而不是equals比较键的一个映射</td>
</tr>
</tbody></table>
<h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h6><p>Java集合类库提供了LinkedList类，这是一个有序集合，可以使用LinkedList.add方法将对象添加到列表的尾部，但是，常常需要将元素添加到列表的中央，这种依赖于位置的add方法由迭代器负责，只有对自然有序地集合使用迭代器添加元素才有意义，例如，在集数据类型中，元素是完全无序的，因此，Iterator接口没有add方法。实际上，集合类库提供了一个子接口ListIterator，其中包含add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于反向遍历列表</span></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</span><br></pre></td></tr></table></figure>

<p>迭代器的set方法会用一个新元素替换调用next或previous方法返回的上一个元素，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter.next();</span><br><span class="line">iter.set(<span class="string">&quot;a&quot;</span>); <span class="comment">//将字符串a置于倒数第二个位置</span></span><br></pre></td></tr></table></figure>

<p>链表提供了访问特定元素的get方法，但是效率不高，因此，需要按整数索引访问元素时，通常不选用列表。</p>
<h6 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h6><p>集合类库提供了ArrayList类，使用get与set方法可以很方便的进行访问，ArrayList类封装了一个动态再分配的对象数组。</p>
<p>ArrayList的方法不是同步的，因此，在进行多线程操作时，应使用更加安全的Vector对象。</p>
<h6 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h6><p>散列表可以用于快速的查找对象，它会为每个对象计算一个整数，称为散列码，散列码是由对象的实例字段得出的一个整数，更准确地说，有不同数据的对象将产生不同的散列码。</p>
<p>在Java中，散列表用链表数组实现。每个列表称为桶，想要查找表中对象的位置，就先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。如果遇到桶已经被填充的情况，就需要将新对象与桶中的所有对象比较，检测这个对象是否已经存在。</p>
<p>通常，将桶数设为预计元素个数的75%~150%。当然，如果遇到散列表太满的情况，就需要进行再散列，这时需要创建一个桶数更多的表，并将所有元素插入新表，然后丢弃原来的表。</p>
<p>Java集合类库提供了HashSet类，它实现了基于散列表的集，可以用add方法添加元素，也可以使用contains方法，来快速查找某个元素是否已经在集中。</p>
<p>散列集迭代器将依次访问1所有的桶，由于散列将元素分布在表中，所以会以一种看起来随机的顺序访问元素，因而，只有不关心集合中元素的顺序时才应该使用HashSet。</p>
<h6 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h6><p>TreeSet类与散列集十分类似，不过它有所改进。树集是一个有序集合，可以以任意顺序插入元素。在对集合进行遍历时，值会自动地按照排序后的顺序呈现，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; s = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        s.add(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;alice&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String item: s)</span><br><span class="line">            System.out.print(item+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 输出a alice bob</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如TreeSet类名所示，排序是使用树状结构完成的（红黑树）。每将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此，迭代器总是以有序地顺序访问每个元素。</p>
<p>将一个元素添加到树中要比添加到散列表慢，但是，与检查数组或链表中的重复元素相比，使用树会快很多。</p>
<h6 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="队列和双端队列"></a>队列和双端队列</h6><p>队列允许高效的在尾部添加元素，并在头部删除元素；双端队列允许在头部和尾部都高效的添加或删除元素。但不支持在队列中间添加元素，队列实现的是Queue接口，双端队列实现的则是Deque接口。</p>
<h6 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h6><p>优先队列中的元素可以按照任意的顺序插入，但会按照有序地顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先队列中最小的元素，不过，优先队列并没有对所有元素进行排序，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; s = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        s.add(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;alice&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(s); <span class="comment">//[a, bob, alice]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())</span><br><span class="line">            System.out.println(s.remove()); <span class="comment">//a alice bob</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与TreeSet一样，优先队列即可以保存实现了Comparable接口的类对象，也可以保存构造器中提供的Comparator对象。</p>
<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>当我们知道某些关键信息，希望查找与之关联的元素时，就要使用到映射。映射用来存放键/值对，如果提供了键，就可以查找到值。例如，可以存储一个员工记录表，其中键为员工ID，值为Employee对象。</p>
<h6 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h6><p>Java类库为映射提供了两个通用的实现：HashMap与TreeMap。这两个类都实现了Map接口。</p>
<p>散列映射对键进行散列，树映射根据键的顺序将元素组织成一个搜索树。散列或比较函数只应用于键，与键关联的值不进行散列或比较。</p>
<p>下面代码将建立一个散列映射来存储员工信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> HashMap&lt;String, Employee&gt;();</span><br><span class="line"><span class="keyword">var</span> harry = <span class="keyword">new</span> Employee(...);</span><br><span class="line">staff.put(<span class="string">&quot;123&quot;</span>, harry);</span><br></pre></td></tr></table></figure>

<p>每向映射中添加一个对象时，必须同时提供一个键。同样，想要检索一个对象，必须使用键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e = staff.get(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果映射中没有存储与给定键值对应的信息，get将返回null，也可以通过getOrDefault方法设置一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee t = staff.getOrDefault(<span class="string">&quot;234&quot;</span>, <span class="keyword">new</span> Employee(...));</span><br></pre></td></tr></table></figure>

<p>键必须是唯一的，不能对同一个键存放两个值。如果对同一个键调用两次put方法，第二个值就会取代第一个值。实际上，put将返回与这个键参数关联的上一个值。</p>
<p>remove方法从映射中删除给定键对应的元素。size方法返回映射中的元素数。</p>
<p>要迭代处理映射的键和值，最容易的方法是使用forEach方法。可以提供一个接受键和值的lambda表达式，映射中的每一项都会依次调用这个表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">staff.forEach((k, v)-&gt;</span><br><span class="line">             System.out.println(k+v));</span><br></pre></td></tr></table></figure>

<h6 id="更新映射条目"><a href="#更新映射条目" class="headerlink" title="更新映射条目"></a>更新映射条目</h6><p>处理映射的一个难点就是更新映射条目，正常情况下，可以得到一个与键关联的一个原值，完成更新，再放回更新后的值。不过，键也有可能是第一次出现。例如，在使用映射统计单词在文件中出现的频率时，每看到一个单词，就将计数器加一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>但是如果这个单词是第一次出现，get方法就会抛出异常。</p>
<p>一种简单的补救就是getOrDefault方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>另一种方法就是调用putIfAbsent方法。只有当键原先存在时才会放入另一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>更好的方法则是调用merge方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>如果键原先不存在，就将word与1关联，否则使用Integer::sum函数组合原值与1。</p>
<h6 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h6><p>可以得到映射的视图，即实现了Collection接口或某个字接口的对象。</p>
<p>有三种视图，键集，值集合（不是一个集）以及键/值对集。下面的方法将分别返回这三个视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<p>如果想同时查看键和值，可以通过枚举映射条目来避免查找值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Employee&gt;&gt; entry: staff.entrySet())&#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Employee val = entry.getValue();</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和它关联的值，但是不能向键集视图添加元素。</p>
<h6 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h6><p>如果有一个值，它对应的键已经不在程序的任何地方使用，但是，由于程序中的任何部分都不会再有这个键，所以，无法从映射中删除这个键/值对。  这时，就需要使用WeakHashMap，当对键的唯一引用来自散列表映射条目时，这个数据结构将与垃圾回收器协同工作一起删除键/值对。</p>
<h6 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h6><p>LinkedHashSet与LinkedHashMap类会记住插入元素项的顺序。这样就可以避免散列表中的项看起来顺序是随机的。</p>
<p>例如，考虑下面的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">staff.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;alice&quot;</span>);</span><br><span class="line">staff.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line">staff.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;carl&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>staff.keySet().iterator()</code>将以下面的次序枚举键：</p>
<p>1 2 3</p>
<p><code>staff.values().iterator()</code>将以下面的次序枚举值：</p>
<p>alice bob carl</p>
<p>或者，链接散列映射可以使用访问顺序而不是插入顺序来迭代处理映射条目。每次调用get或put时，受到影响的项将从当前位置删除，并放到项链表的尾部，构造这样的散列映射，需要调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity, load_factor, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>可以自定义置换的过程，只需要构造LinkedHashMap的子类，然后覆盖下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.entry&lt;K, V&gt; eldest)</span></span></span><br></pre></td></tr></table></figure>

<p>每当该方法返回true时，添加一个新的映射条目就会导致删除eldest项。</p>
<h6 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h6><p>EnumSet是一个枚举类型元素集的高效实现，该类没有公共的构造器，要使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">weekDay</span> </span>&#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EnumSet&lt;weekDay&gt; s1 = EnumSet.allOf(weekDay.class);</span><br><span class="line">        EnumSet&lt;weekDay&gt; s2 = EnumSet.noneOf(weekDay.class);</span><br><span class="line">        EnumSet&lt;weekDay&gt; s3 = EnumSet.range(weekDay.MONDAY, weekDay.SATURDAY);</span><br><span class="line">        EnumSet&lt;weekDay&gt; s4 = EnumSet.of(weekDay.MONDAY, weekDay.WEDNESDAY);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的输出为</p>
<p><strong>[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</strong><br><strong>[]</strong><br><strong>[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]</strong><br><strong>[MONDAY, WEDNESDAY]</strong></p>
<p>可以使用Set接口的常用方法来修改EnumSet。</p>
<p>EnumMap是一个键类型为枚举类型的映射，它可以直接而高效的实现为一个值数组。但需要在构造器中指定键类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> day = <span class="keyword">new</span> EnumMap&lt;weekDay, String&gt;(weekDay.class);</span><br><span class="line">day.put(weekDay.MODDAY, <span class="string">&quot;周一&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h6 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h6><p>类IdentityHashMap有特殊的用途，在这个类中，键的散列值不使用hashCode函数计算，而是使用了System.identityHashCode方法，而且在对两个对象进行比较时，IdentityHashMap类使用==，而不是equals。</p>
<p>也就是说，不同的键对象即使内容相同，也会被视为不同的对象。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来追踪哪些对象已经遍历过。</p>
<h5 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h5><p>可以使用视图获得其他实现了Collection接口或Map接口的对象，例如映射类的keySet方法，keySet方法返回一个实现了Set接口的类对象，由这个类的方法操纵原映射，这种集合称为视图。</p>
<h6 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h6><p>Java9引入了一些静态方法，可以生成给定元素的集或列表，以及给定键/值对的映射，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;carl&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; nums = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>对于映射，需要指定键和值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; scores = Map.of(<span class="string">&quot;alice&quot;</span>, <span class="number">1</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">2</span>, <span class="string">&quot;carl&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>元素，键或值不能为null。</p>
<p>List和Set接口有11个方法，分别有0-10个参数，另外还有一个参数可变的of方法。提供这种特定性是为了提高效率。</p>
<p>对于Map接口，则无法提供一个参数可变的版本，因为参数类型会在键与值的类型之间交替。不过它有一个静态方法ofEntries，能接受任意多个Map.Entry&lt;K, V&gt;对象，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; scores = Map.ofEntries(Map.entry(<span class="string">&quot;alice&quot;</span>, <span class="number">1</span>), Map.entry(<span class="string">&quot;bob&quot;</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>of与ofEntries方法可以生成某些类的对象，这些类对于每个元素会有一个实例变量，或者有一个后备数组提供支持。</p>
<p>这些集合对象是不可修改的。如果试图改变，会导致一个UnsupportedOperationException异常。</p>
<p>如果需要一个可更改的集合，可以把这个不可修改集合传递到构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> ArrayList&lt;String&gt;(List.of(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;carl&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>以下的方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.nCopies(n, anObject);</span><br></pre></td></tr></table></figure>

<p>会返回一个实现了List接口的不可变的对象，但不是n个元素，每个元素返回一个anObject，事实上，这个对象仅存储了一次。</p>
<h6 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h6><p>可以为很多集合建立子范围视图，例如，假设有一个列表staff，想从中获取10~19个元素，就可以使用subList方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; group = staff.subList(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>第一个索引包含在内，第二个索引则不包含。</p>
<p>可以对子范围应用任何操作，而且操作会自动反映到整个列表，例如，可以删除整个子范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.clear();</span><br></pre></td></tr></table></figure>

<p>对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围，SortedSet接口声明了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, E to)</span></span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法将返回大于等于from且小于to的所有元素构成的子集。有序映射也有类似的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from, K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法会返回映射视图，该映射包含键落在指定范围内的所有元素。</p>
<p>Java6引入的NavigableSet接口允许更多的控制这些子范围操作，可以指定是否包括边界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive, E to, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive)</span></span></span><br></pre></td></tr></table></figure>

<h6 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h6><p>Collections类还有几个方法，可以生成集合的不可修改视图，这些视图对现有的集合增加了一个运行时检查。如果发现试图对集合进行修改，就抛出一个异常，集合仍保持不变。</p>
<p>可以使用下面八个方法来获得不可修改视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>

<p>每个方法都定义处理一个接口，假设想要你的代码查看（但不能修改）一个集合的内容，就可以进行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line">lookat(Collections.unmodifiableList(staff));</span><br></pre></td></tr></table></figure>

<p>Collections.unmodifiableList方法将返回一个实现了List接口的类对象，其访问器方法将从staff集合获取值。但lookat方法调用更改器方法时，会抛出异常而不是将调用传给底层集合。</p>
<p>不可修改视图并非集合本身不可修改，仍然可以通过集合的原始引用对集合进行修改或调用更改器方法。</p>
<h6 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h6><p>如果从多个线程访问集合，就必须确保集合不会被意外破坏。类库的设计者使用视图机制来确保常规集合是线程安全的，而没有实现线程安全的集合类。例如，Collections类的静态方法synchronizedMap方法可以将任何一个映射转换成有同步访问方法的Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer, String&gt;());</span><br></pre></td></tr></table></figure>

<h6 id="检查型视图"><a href="#检查型视图" class="headerlink" title="检查型视图"></a>检查型视图</h6><p>检查型视图用来对泛型类型可能出现的问题提供调试支持。实际中，将错误类型的元素混入泛型集合中的情况极有可能发生，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList raw = str; <span class="comment">//warning</span></span><br><span class="line">raw.add(<span class="keyword">new</span> Date()); </span><br></pre></td></tr></table></figure>

<p>这个错误的add命令在运行时检测不到，只有在另一部分代码调用get方法时，才会出现一个强制转换异常，检查型视图可以探测这类问题，下面定义了一个安全列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safe = Collections.checkedList(str, String.class);</span><br></pre></td></tr></table></figure>

<p>这个视图的add方法将检查插入的对象是否属于给定的类，如果不属于，就会立即抛出一个ClassCastException，这样就可以在正确的位置报告异常。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>除了实现集合类，Java集合框架还提供了一些有用的算法。</p>
<h6 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h6><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>

<p>这个方法假定列表元素实现了Comparable接口，如果想使用其他方法进行排序，可以使用List接口的sort方法并传入一个Comparator对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary()));</span><br></pre></td></tr></table></figure>

<p>如果想按照降序排序，可以使用静态方法Collections.reverseOrder，这个方法将返回一个比较器，比较器则返回b.compare(a)，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>同样的，可以将工资降序排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary()).reversed());</span><br></pre></td></tr></table></figure>

<p>Collections类还有一个算法shuffle，其功能与排序刚好相反，它会随机的混排列表中元素的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle(staff);</span><br></pre></td></tr></table></figure>

<h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>Collections类的binSerach方法实现了二分查找算法，但集合必须是有序地，否则会返回错误的答案。要想查找某个元素，必须提供集合以及要查找的元素。如果集合没有采用Comparable接口的compareTo方法进行排序，就还要提供一个比较器对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = Collections.binarySerach(c, element);</span><br><span class="line">i = Collections.binarySearch(c, element, comparator);</span><br></pre></td></tr></table></figure>

<p>如果方法返回一个非负的值，则表示匹配对象的索引，若为负值，则表示没有匹配。</p>
<h6 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h6><p>如果需要把一个数组转换为集合，List.of包装器可以达到这个目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] vals = ...;</span><br><span class="line"><span class="keyword">var</span> staff = List.of(vals);</span><br></pre></td></tr></table></figure>

<p>从集合得到数组则使用toArray方法，并提供一个指定类型且长度为0的数组，这样返回的数组类型就不是Object：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OOP/" rel="tag"># OOP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/03/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="prev" title="泛型程序设计">
                  <i class="fa fa-chevron-left"></i> 泛型程序设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/11/%E5%B9%B6%E5%8F%91/" rel="next" title="并发">
                  并发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈旭东</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

  

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
